//
// Copyright (c) 2023-2024 Kris Jusiak (kris at jusiak dot net)
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
#if __cplusplus < 202002L
#error "SML2 requires C++20 support (Clang-15+, GCC-12+)"
#else
#if defined(__cpp_modules)
export module sml;
export  // namespace
#else
#ifndef SML2
#define SML2 2'0'0
#pragma GCC system_header  // -Wnon-template-friend
#endif

// clang-format off
/**
 * SML2
 * C++20 single header/module - https://raw.githubusercontent.com/boost-ext/sml2/main/sml2
 * No dependencies (Neither Boost nor STL is required) No 'virtual' used (-fno-rtti)
 * No `exceptions` required (-fno-exceptions)
 * Library tests itself at compile-time upon include/import Basically guaranteed no UB, no leaks
 * Optimized run-time execution - https://godbolt.org/z/y99L50
 * Fast compilation times
 * Declarative Domain Specific Language (DSL)
 */
// clang-format on
namespace sml::inline v_2_0_0 {
namespace meta {
template <auto Value>
struct bool_constant {
  static constexpr auto value = Value;
};
template <auto...>
struct index_sequence {};
template <class T, T... Ns>
using integer_sequence = index_sequence<Ns...>;
template <auto N>
using make_index_sequence =
#if __has_builtin(__make_integer_seq)
    __make_integer_seq<integer_sequence, decltype(N), N>;
#elif __has_builtin(__integer_pack)
    index_sequence<__integer_pack(N)...>;
#endif

template <class T>
auto declval() -> T&&;

template <auto N>
struct fixed_hash_string {
  static constexpr auto size = N;

  constexpr fixed_hash_string() = default;
  constexpr explicit(false) fixed_hash_string(const char (&str)[N + 1]) {
    for (auto i = 0u; i < N; ++i) {
      data[i] = str[i];
      (hash ^= data[i]) <<= 1;
    }
  }

  constexpr auto operator*() const {
    fixed_hash_string<N + 1> str{};
    str.data[0] = '*';
    for (auto i = 0u; i < N; ++i) {
      str.data[i + 1] = data[i];
      (str.hash ^= str.data[i + 1]) <<= 1;
    }
    return str;
  }

  char data[N + 1]{};
  unsigned hash{};
};

template <auto N>
fixed_hash_string(const char (&str)[N]) -> fixed_hash_string<N - 1>;
template <class...>
struct type_list {};
template <class T, template <class...> class TList, class... Ts>
auto append(TList<Ts...>) -> TList<Ts..., T>;
}  // namespace meta

namespace back {
template <class... Ts>
struct pool : Ts... {
  constexpr explicit(true) pool(Ts... ts) : Ts{ts}... {}
};

template <class...>
class sm;
template <template <class...> class TList, class... Transitions>
class sm<TList<Transitions...>> {
  template <auto N, class T>
  struct prediction {
    static constexpr auto next = N;
    using type = T;
  };
  template <class, auto>
  struct cache {
    constexpr auto friend get(cache);
  };
  template <class, auto>
  struct predict {
    constexpr auto friend get(predict);
  };
  template <class T, class R>
  struct set {
    constexpr auto friend get(T) { return R{}; }
  };
  template <class... Ts>
  using transitions = meta::type_list<Ts...>;

  template <class TEvent, class T, auto N, auto I = 0>
  static constexpr auto set_transitions_impl() {
    if constexpr (requires { get(predict<TEvent, N>{}); }) {
      using predicted = decltype(get(predict<TEvent, N>{}));
      using updated = decltype(meta::append<T>(typename predicted::type{}));
      set<cache<TEvent, predicted::next>, updated>();
      set<predict<TEvent, N + 1>, prediction<predicted::next + 1, updated>>();
    } else if constexpr (requires { get(cache<TEvent, I>{}); }) {
      set_transitions_impl<TEvent, T, N, I + 1>();
    } else if constexpr (not I) {
      set<cache<TEvent, I>, transitions<T>>();
      set<predict<TEvent, N + 1>, prediction<I + 1, transitions<T>>>();
    } else {
      using updated = decltype(meta::append<T>(get(cache<TEvent, I - 1>{})));
      set<cache<TEvent, I>, updated>();
      set<predict<TEvent, N + 1>, prediction<I + 1, updated>>();
    }
  }

  template <class T, auto N, class... TEvents>
  static constexpr auto set_transitions(meta::type_list<TEvents...>) {
    (set_transitions_impl<TEvents, T, N>(), ...);
  }

  template <class TEvent, auto I = 1>
  [[nodiscard]] static constexpr auto get_transitions() {
    if constexpr (requires { get(cache<TEvent, I>{}); }) {
      return get_transitions<TEvent, I + 1>();
    } else if constexpr (requires {
                           get(cache<TEvent, I - 1>{});
                         }) {  // can be unexpected
      return get(cache<TEvent, I - 1>{});
    }
  }

  static_assert((
      []<auto... Ns>(meta::index_sequence<Ns...>) {
        using swallow = bool[];
        void(swallow{
            (set_transitions<Transitions, Ns>(typename Transitions::event{}),
             true)...});
      }(meta::make_index_sequence<sizeof...(Transitions)>{}),
      true));

  static constexpr auto num_of_regions =
      ((Transitions::src.data[0] == '*') + ...);

  using state_t = unsigned;

 public:
  constexpr explicit(true) sm(const auto& transition_table)
      : transition_table_{transition_table} {
    const state_t states[]{
        (Transitions::src.data[0] == '*' ? Transitions::src.hash : 0u)...};
    for (auto* current_state = &current_state_[0]; auto state : states) {
      if (state) {
        *current_state++ = state;
      }
    }
  }

  template <class TEvent, const auto transitions = get_transitions<TEvent>()>
  constexpr auto process_event(const TEvent& event, auto&&... args) -> bool {
    if constexpr (num_of_regions == 0u) {
      return process_event_0<TEvent>(event, transitions, args...);
    } else if constexpr (num_of_regions == 1u) {
      return process_event_1<TEvent>(event, current_state_[0], transitions,
                                     args...);
    } else {
      return process_event_N<TEvent>(
          event, transitions, meta::make_index_sequence<num_of_regions>{},
          args...);
    }
  }

  [[nodiscard]] constexpr auto is(auto... states) const -> bool
    requires(num_of_regions > 0u)
  {
    unsigned i{};
    return ((states.src.hash == current_state_[i++]) and ...);
  }

 private:
  template <class TEvent, class T>
  constexpr auto process_event_0(const TEvent& event, transitions<T>,
                                 auto&&... args) -> bool {
    state_t arg{};
    return static_cast<T&>(transition_table_)(event, arg, *this, args...);
  }

  template <class TEvent, class... Ts>
  constexpr auto process_event_0(const TEvent& event, transitions<Ts...>,
                                 auto&&... args) -> bool {
    return (process_event_0(event, transitions<Ts>{}, args...) or ...);
  }

  template <class TEvent, class T>
  constexpr auto process_event_1(const TEvent& event, auto& current_state,
                                 transitions<T>, auto&&... args) -> bool {
    return (T::src.hash == current_state or not T::src.hash) and
           static_cast<T&>(transition_table_)(event, current_state, *this,
                                              args...);
  }

  template <class TEvent, class... Ts>
  constexpr auto process_event_1(const TEvent& event, auto& current_state,
                                 transitions<Ts...>, auto&&... args) -> bool {
    return (process_event_1(event, current_state, transitions<Ts>{}, args...) or
            ...);
  }

  template <class TEvent, auto... Rs>
  constexpr auto process_event_N(const TEvent& event, const auto& transitions,
                                 meta::index_sequence<Rs...>, auto&&... args)
      -> bool {
    return (process_event_1<TEvent>(event, current_state_[Rs], transitions,
                                    args...) or
            ...);
  }

  [[no_unique_address]] TList<Transitions...> transition_table_{};
  [[no_unique_address]] state_t
      current_state_[not num_of_regions ? 1 : num_of_regions]{};
};
}  // namespace back

namespace front {
namespace concepts {
struct invocable_base {
  void operator()();
};
template <class T>
struct invocable_impl : T, invocable_base {};
template <class T>
concept invocable = not requires { &invocable_impl<T>::operator(); };
}  // namespace concepts

[[nodiscard]] constexpr auto invoke(const auto& fn, const auto& event,
                                    auto& self, auto&&... args) {
  if constexpr (requires { fn(event, args...); }) {
    return fn(event, args...);
  } else if constexpr (requires { fn(event); }) {
    return fn(event);
  } else if constexpr (requires { fn(self, event, args...); }) {
    return fn(self, event, args...);
  } else {
    return fn();
  }
}

namespace detail {
constexpr auto none = [] {};
constexpr auto always = [] { return true; };
}  // namespace detail

template <
    meta::fixed_hash_string Src = "", class TEvent = decltype(detail::none),
    class TGuard = decltype(detail::always),
    class TAction = decltype(detail::none), meta::fixed_hash_string Dst = "">
struct transition {
  static constexpr auto src = Src;
  static constexpr auto dst = Dst;
  using event = TEvent;

  [[nodiscard]] constexpr auto operator*() const {
    return transition<*Src, TEvent, TGuard, TAction, Dst>{.guard = guard,
                                                          .action = action};
  }

  template <class T>
  [[nodiscard]] constexpr auto operator+(const T& t) const {
    return transition<Src, typename T::event, decltype(T::guard),
                      decltype(T::action)>{.guard = t.guard,
                                           .action = t.action};
  }

  template <class T>
  [[nodiscard]] constexpr auto operator[](const T& guard) const {
    return transition<Src, TEvent, T>{.guard = guard, .action = action};
  }

  template <class T>
  [[nodiscard]] constexpr auto operator/(const T& action) const {
    return transition<Src, TEvent, TGuard, T>{.guard = guard, .action = action};
  }

  template <class T>
  [[nodiscard]] constexpr auto operator=(const T&) const {
    return transition<src, TEvent, TGuard, TAction, T::src>{.guard = guard,
                                                            .action = action};
  }

  [[nodiscard]] constexpr auto operator()(const auto& event,
                                          [[maybe_unused]] auto& current_state,
                                          auto& self, auto&&... args) -> bool {
    using R = decltype(invoke(guard, event, self, args...));
    if constexpr (requires { R::value; }) {
      if constexpr (R::value) {
        if constexpr (dst.size) {
          current_state = dst.hash;
        }
        invoke(action, event, self, args...);
        return true;
      }
    } else {
      if (invoke(guard, event, self, args...)) {
        if constexpr (dst.size) {
          current_state = dst.hash;
        }
        invoke(action, event, self, args...);
        return true;
      }
    }
    return false;
  }

  [[no_unique_address]] TGuard guard;
  [[no_unique_address]] TAction action;
};

template <class... TEvents>
constexpr auto event = transition<"", meta::type_list<TEvents...>>{};
template <meta::fixed_hash_string Str>
constexpr auto operator""_s() {
  return transition<Str>{};
}

[[nodiscard]] constexpr auto operator,(const concepts::invocable auto& lhs,
                                       const concepts::invocable auto& rhs) {
  return [=](auto& self, const auto& event, auto&&... args) {
    invoke(lhs, event, self, args...);
    invoke(rhs, event, self, args...);
  };
}
[[nodiscard]] constexpr auto operator and(const concepts::invocable auto& lhs,
                                          const concepts::invocable auto& rhs) {
  return [=](auto& self, const auto& event, auto&&... args) {
    return invoke(lhs, event, self, args...) and
           invoke(rhs, event, self, args...);
  };
}
[[nodiscard]] constexpr auto operator or(const concepts::invocable auto& lhs,
                                         const concepts::invocable auto& rhs) {
  return [=](auto& self, const auto& event, auto&&... args) {
    return invoke(lhs, event, self, args...) or
           invoke(rhs, event, self, args...);
  };
}
[[nodiscard]] constexpr auto operator not(const concepts::invocable auto& t) {
  return [=](auto& self, const auto& event, auto&&... args) {
    return not invoke(t, event, self, args...);
  };
}
}  // namespace front

template <class T>
struct sm final : back::sm<decltype(meta::declval<T>()())> {
  constexpr explicit(false) sm(T t)
      : back::sm<decltype(meta::declval<T>()())>{t()} {}
};
template <class T>
sm(T&&) -> sm<T>;

namespace dsl {
template <class... Ts>
struct transition_table : back::pool<Ts...> {
  constexpr explicit(false) transition_table(Ts... ts)
      : back::pool<Ts...>{ts...} {}
  static_assert(
      ((Ts::src.data[0] == '*') + ...) >= 1,
      "[E001] At least one `*state` aka orthogonal region is required!");
};
template <class... Ts>
struct dispatch_table : back::pool<Ts...> {
  constexpr explicit(false) dispatch_table(Ts... ts)
      : back::pool<Ts...>{ts...} {}
};
using front::event;
using front::operator""_s;
using front::operator, ;
using front::operator not;
using front::operator and;
using front::operator or;
constexpr auto otherwise = [] { return true; };
constexpr auto _ = ""_s;   // any state
constexpr auto X = "X"_s;  // terminate state
constexpr auto process = [](const auto& event) {
  return [event](auto& self, const auto&, auto&&...) {
    self.process_event(event);
  };
};
}  // namespace dsl
}  // namespace sml::inline v_2_0_0

/**
 * Tests
 */

static_assert(
    [] {
      using namespace sml;

      struct e1 {};

      struct test {
        constexpr auto operator()() const {
          using namespace dsl;
          return transition_table{
              *"s1"_s + event<e1> = "s2"_s,
          };
        }
      };

      using dsl::operator""_s;

      test t;
      sm sm1{t};
      sm sm2{test{}};
      return sm1.is("s1"_s) and sm1.process_event(e1{}) and sm1.is("s2"_s) and
             sm2.is("s1"_s) and sm2.process_event(e1{}) and sm2.is("s2"_s);
    }(),
    "feature.ctor");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
        };
      };

      using dsl::operator""_s;
      return sm.process_event(e1{}) and sm.is("s2"_s);
    }(),
    "feature.process_event");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
            "s2"_s + event<e1> = "s3"_s,
        };
      };

      using dsl::operator""_s;
      return sm.process_event(e1{}) and sm.is("s2"_s) and
             sm.process_event(e1{}) and sm.is("s3"_s);
    }(),
    "feature.process_event[same event multiple times]");

static_assert(
    [] {
      using namespace sml;

      struct e {
        int value{};
      };
      unsigned value{};

      sm sm = [&] {
        using namespace dsl;
        auto action = [&](const auto& event, auto... args) {
          value += event.value + (args + ...);
        };
        return transition_table{
            *"s1"_s + event<e> / action,
        };
      };

      using dsl::operator""_s;
      return sm.process_event(e{.value = 1}, 2, 3) and 6 == value;
    }(),
    "feature.process_event[with parameters]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};
      struct e {
        int value{};
      };

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
            "s2"_s + event<e2> = "s3"_s,
            "s3"_s + event<e2> = X,
            _ + event<e> = "s1"_s,
        };
      };

      using dsl::operator""_s;

      return sm.process_event(e1{}) and sm.is("s2"_s) and

             sm.process_event(e{{}}) and                       // _ -> s1
             sm.is("s1"_s) and not sm.process_event(e2{}) and  // ignored
             sm.is("s1"_s) and

             sm.process_event(e1{}) and  // s1 -> s2
             sm.is("s2"_s) and

             sm.process_event(e2{}) and  // s2 -> s3
             sm.is("s3"_s) and

             sm.process_event(e{}) and  // _ -> s1
             sm.is("s1"_s);
    }(),
    "feature.process_event[different events in any state]");

static_assert(
    [] {
      using namespace sml;
      struct unexpected {};
      struct e1 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
        };
      };

      constexpr auto process_event = [](auto event) {
        return requires { sm.process_event(event); };
      };

      static_assert(process_event(e1{}));
      static_assert(not process_event(unexpected{}));
      return true;
    }(),
    "feature.proces_event[unexpected event]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};

      const auto test = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1, e2> = "s2"_s,
        };
      };

      using dsl::operator""_s;

      return [&] {
        sm sm{test};
        return sm.is("s1"_s) and sm.process_event(e1{}) and sm.is("s2"_s);
      }() and [&] {
        sm sm{test};
        return sm.is("s1"_s) and sm.process_event(e2{}) and sm.is("s2"_s);
      }();
    }(),
    "feature.events[multiple events]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};

      const auto test = [] {
        using namespace dsl;
        return transition_table{
            *"idle"_s + event<e1> / [] {} = "s1"_s,
            "s1"_s + event<e1> / [] {} = "s2"_s,
            "s2"_s + event<e1> / [] {} = "idle"_s,
        };
      };

      sm sm{test};
      using dsl::operator""_s;
      return sm.is("idle"_s) and sm.process_event(e1{}) and sm.is("s1"_s) and
             sm.process_event(e1{}) and sm.is("s2"_s) and
             sm.process_event(e1{}) and sm.is("idle"_s);
    }(),
    "feature.events[same event transitions]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
            "s2"_s + event<e2> = "s1"_s,
        };
      };

      using dsl::operator""_s;

      return sm.is("s1"_s) and sm.process_event(e1{}) and sm.is("s2"_s) and
             not sm.process_event(e1{}) and sm.is("s2"_s) and
             sm.process_event(e2{}) and sm.is("s1"_s);
    }(),
    "feature.transition_table[multiple transitions]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = X,
        };
      };

      using dsl::operator""_s;
      using dsl::X;
      return sm.is("s1"_s) and sm.process_event(e1{}) and sm.is(X) and
             not sm.process_event(e1{});
    }(),
    "feature.transition_table[terminated state]");

static_assert(
    [] {
      using namespace sml;

      struct e {
        int value;
      };

      unsigned calls{};

      sm sm = [&] {
        using namespace dsl;
        auto guard = [](const auto& event) { return event.value; };
        auto action = [&] { ++calls; };
        return transition_table{
            *"s1"_s + event<e>[guard and (guard or guard)] / (action, action) =
                "s2"_s,
        };
      };

      using dsl::operator""_s;
      return not sm.process_event(e{false}) and sm.is("s1"_s) and
             sm.process_event(e{true}) and sm.is("s2"_s);
    }(),
    "feature.transition_table[guards/actions]");

static_assert(
    [] {
      using namespace sml;

      struct e {
        int value{};
      };

      sm sm = [&] {
        using namespace dsl;
        constexpr auto guard = [](const auto& event) { return event.value; };
        return transition_table{
            *"s1"_s + event<e>[guard] = "s2"_s,
            "s1"_s + event<e>[otherwise] = "s3"_s,
        };
      };

      using dsl::operator""_s;
      return sm.process_event(e{false}) and sm.is("s3"_s);
    }(),
    "feature.transition_table[otherwise guard]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {
        int value{};
      };
      struct e2 {};

      unsigned value{};

      sm sm = [&] {
        using namespace dsl;
        auto ct_guard = [](const auto& event) {
          return sml::meta::bool_constant<requires { event.value; }>{};
        };
        auto action = [&](const auto& event) { value += event.value; };
        return transition_table{
            *"s1"_s + event<e1>[ct_guard] / action,
            "s1"_s + event<e2>[ct_guard] / action,
        };
      };

      using dsl::operator""_s;
      return 0 == value and sm.process_event(e1{.value = 42}) and
             42 == value and not sm.process_event(e2{}) and 42 == value;
    }(),
    "feature.transition_table[constexpr guards]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> / process(e2{}) = "s2"_s,
            "s2"_s + event<e2> = "s3"_s,
        };
      };

      using dsl::operator""_s;
      return sm.process_event(e1{}) and sm.is("s3"_s);
    }(),
    "feature.transition_table[process]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
            *"s3"_s + event<e2> = "s4"_s,
        };
      };

      using dsl::operator""_s;
      return sm.is("s1"_s, "s3"_s) and sm.process_event(e1{}) and
             sm.is("s2"_s, "s3"_s) and sm.process_event(e2{}) and
             sm.is("s2"_s, "s4"_s);
    }(),
    "feature.transition_table[orthogonal regions]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};
      struct e3 {};

      sm sm = [] {
        using namespace dsl;
        return transition_table{
            *"s1"_s + event<e1> = "s2"_s,
            "s2"_s + event<e2> = X,
            // -------------------------
            *"s3"_s + event<e3> = X,
        };
      };

      using dsl::operator""_s;
      using dsl::X;
      return sm.is("s1"_s, "s3"_s) and sm.process_event(e1{}) and
             sm.is("s2"_s, "s3"_s) and sm.process_event(e2{}) and
             sm.is(X, "s3"_s) and sm.process_event(e3{}) and sm.is(X, X);
    }(),
    "feature.transition_table[orthogonal regions]");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};
      struct e2 {};

      unsigned calls{};
      auto guard = [] { return true; };
      auto action = [&] { ++calls; };

      sm sm = [=] {
        using namespace dsl;
        return dispatch_table{
            event<e1>[guard] / action,
            event<e2>[guard] / action,
        };
      };

      using dsl::operator""_s;
      return 0 == calls and sm.process_event(e1{}) and 1 == calls and
             sm.process_event(e2{}) and 2 == calls;
    }(),
    "feature.dispatch_table");

static_assert(
    [] {
      using namespace sml;

      struct e1 {};

      struct s {
        bool value{};

        constexpr auto operator()() const {
          using namespace dsl;
          auto guard = [this] { return value; };
          return transition_table{
              *"s1"_s + event<e1>[guard] = "s2"_s,
          };
        }
      };

      using dsl::operator""_s;
      return [&] {
        s s{};
        sm sm{s};
        return not sm.process_event(e1{}) and sm.is("s1"_s);
      }() and [&] {
        s s{true};
        sm sm{s};
        return sm.process_event(e1{}) and sm.is("s2"_s);
      }();
    }(),
    "feature.dependencies");

/**
 * Examples
 */

static_assert(
    [] {
      struct connect {};
      struct established {};
      struct ping {};
      struct disconnect {};
      struct timeout {};

      struct Connection {
        constexpr auto operator()() const {
          constexpr auto establish = [] {};
          constexpr auto close = [] {};
          constexpr auto is_valid = [](auto const&) { return true; };
          constexpr auto reset_timeout = [] {};

          using namespace sml::dsl;
          return transition_table{
              *"Disconnected"_s + event<connect> / establish = "Connecting"_s,
              "Connecting"_s + event<established> = "Connected"_s,
              "Connected"_s + event<ping>[is_valid] / reset_timeout,
              "Connected"_s + event<timeout> / establish = "Connecting"_s,
              "Connected"_s + event<disconnect> / close = "Disconnected"_s,
          };
        }
      };

      sml::sm connection{Connection{}};
      using sml::dsl::operator""_s;
      return connection.is("Disconnected"_s) and
             connection.process_event(connect{}) and
             connection.is("Connecting"_s) and
             connection.process_event(established{}) and
             connection.is("Connected"_s) and
             connection.process_event(ping{}) and
             connection.is("Connected"_s) and
             connection.process_event(disconnect{}) and
             connection.is("Disconnected"_s);
    }(),
    "example.connection");

#if not defined(__cpp_modules)
#endif  // SML2
#endif
#endif
